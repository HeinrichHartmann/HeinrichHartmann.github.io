<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   <title>Dijkstra's Prime Number Algorithm</title>
   <meta name="author" content="Heinrich Hartmann" />

   <!-- syntax highlighting CSS -->
   <link rel="stylesheet" href="/css/syntax.css" type="text/css" />

   <!-- Homepage CSS -->
   <link rel="stylesheet" href="/css/screen.css" type="text/css" media="screen, projection" />

   <!-- RSS feed -->
   <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml">
</head>
<body>

<div class="site">
  <div class="title">
    <a href="/">Heinrich Hartmann</a>
    <a class="extra" href="/opinion.html">opinion</a>
    <a class="extra" href="/consulting.html">consulting</a>
    <a class="extra" href="/about.html">about</a>
    <div style='float:right'>
      <a href="http://eepurl.com/ccmH-T"><img src="/images/mail_icon.svg" width="25px"/></a>
    </div>
    <div style='float:right'>
      <a href="http://twitter.com/intent/follow?screen_name=HeinrichHartman"><img src="/images/twitter_icon.svg" width="25px" style="margin: 0 10px 0 0;"></a>
    </div>
  </div>

  <div id="headline" style="width:100%">
  <h1 style="float:left">Dijkstra's Prime Number Algorithm</h1>
  <span class='date' style="float:right">
    <span class='quo'>&laquo;</span>
    2016-04-03
    <span class='quo'>&raquo;</span>
  </span>
  <div style="clear:both"></div>
</div>

<div id="post">
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>

<style> .center { margin-right: auto; margin-left:auto; display: block } </style>

<style src="/css/coderay.css"></style>

<p>I was reading Tanenbaum’s paper [1] lately, which contains an
algorithm for calculating prime numbers attributed to E.W. Dijkstra
[2].  What is remarkable about this algorithm is, that it uses no
divisions at all! <sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>  Just a very innocent looking check for inequality
is performed to single out divisible numbers.</p>

<p>The algorithm was given as an example for a special purpose language
SAL.  Here is a literal translation of this algorithm to
<a href="https://www.lua.org/">lua</a>, in its full glory:</p>

<figure class="highlight"><pre><code class="language-lua" data-lang="lua"><span class="kd">local</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">100</span>
<span class="kd">local</span> <span class="n">M</span> <span class="o">=</span> <span class="mi">10</span>
<span class="k">function</span> <span class="nf">PRIME</span><span class="p">()</span>  <span class="c1">-- PROCEDURE DECLARATION;</span>
  <span class="kd">local</span> <span class="n">X</span><span class="p">,</span> <span class="n">SQUARE</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">LIM</span><span class="p">,</span> <span class="n">PRIM</span> <span class="c1">-- DECLARATION OF VARIABLES;</span>
  <span class="kd">local</span> <span class="n">P</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{}</span>
  <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1">-- ASSIGNMENT TO FIRST ELEMENT OF p;</span>
  <span class="nb">print</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">-- OUTPUT A LINE CONTAINING THE NUMBER 2;</span>
  <span class="n">X</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">LIM</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">SQUARE</span> <span class="o">=</span> <span class="mi">4</span>
  <span class="k">for</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">N</span> <span class="k">do</span> <span class="c1">-- LOOP. I TAKES ON 2, 3, ... N;</span>
    <span class="k">repeat</span> <span class="c1">-- STOPS WHEN "UNTIL" CONDITION IS TRUE;</span>
      <span class="n">X</span> <span class="o">=</span> <span class="n">X</span> <span class="o">+</span> <span class="mi">2</span>
      <span class="k">if</span> <span class="n">SQUARE</span> <span class="o">&lt;=</span> <span class="n">X</span> <span class="k">then</span>
        <span class="n">V</span><span class="p">[</span><span class="n">LIM</span><span class="p">]</span> <span class="o">=</span> <span class="n">SQUARE</span>
        <span class="n">LIM</span> <span class="o">=</span> <span class="n">LIM</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">SQUARE</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">LIM</span><span class="p">]</span> <span class="o">*</span> <span class="n">P</span><span class="p">[</span><span class="n">LIM</span><span class="p">]</span>
      <span class="k">end</span>
      <span class="kd">local</span> <span class="n">K</span> <span class="o">=</span> <span class="mi">2</span>
      <span class="kd">local</span> <span class="n">PRIM</span> <span class="o">=</span> <span class="kc">true</span>
      <span class="k">while</span> <span class="n">PRIM</span> <span class="ow">and</span> <span class="n">K</span> <span class="o">&lt;</span> <span class="n">LIM</span> <span class="k">do</span>
        <span class="k">if</span> <span class="n">V</span><span class="p">[</span><span class="n">K</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">X</span> <span class="k">then</span>
          <span class="n">V</span><span class="p">[</span><span class="n">K</span><span class="p">]</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="n">K</span><span class="p">]</span> <span class="o">+</span> <span class="n">P</span><span class="p">[</span><span class="n">K</span><span class="p">]</span>
        <span class="k">end</span>
        <span class="n">PRIM</span> <span class="o">=</span> <span class="n">X</span> <span class="o">~=</span> <span class="n">V</span><span class="p">[</span><span class="n">K</span><span class="p">]</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">K</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="k">end</span>
    <span class="k">until</span> <span class="n">PRIM</span> <span class="c1">-- THIS LINE CLOSES THE REPEAT</span>
    <span class="n">P</span><span class="p">[</span><span class="n">I</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="n">PRIME</span><span class="p">()</span></code></pre></figure>

<p>By running this program, you can quickly verify that it produces a a
list of the first 100 prime numbers. (The 100th prime number is <code class="highlighter-rouge">541</code>,
who would have thought?).
But even after looking at the algorithm for a while, I was not quite
able to make sense out of it. Can you?</p>

<h2 id="a-refactored-version">A refactored version</h2>

<p>Let’s see if we can make this rather acrane program more readable by
refactoring it into a form that is more ‘modern’ idiomatic and
easier to comprehend. The result is the following listing:</p>

<figure id="figure-1"><a href="/assets/Dijkstra_files/typed.png"><img src="/assets/Dijkstra_files/typed.png" alt="A  refactored version of Dijkstras prime number algorithm" /></a><figcaption>Figure 1: A  refactored version of Dijkstras prime number algorithm [<a href="/assets/Dijkstra_files/typed.png">PNG</a>]</figcaption></figure>

<p>Aside: As you can see, this algorithm also served as the perfect
material for testing out my shiny old “Triumph Durabel” typewriter,
from the 1940ies.</p>

<p>If you don’t like typewriters, you can have a look a the code on
<a href="https://github.com/HeinrichHartmann/DijkstraPrimes/blob/master/Primes.lua">Github</a>.
The
<a href="https://github.com/HeinrichHartmann/DijkstraPrimes/commits/master">commit history</a>,
shows how you can arrive at this refactored version in 14 simple
transformations, that did not change the results of the computation,
such as:</p>

<ul>
  <li>Change variable names.</li>
  <li>Don’t use print statements for output, but return a table.</li>
  <li>Remove iteration indices <code class="highlighter-rouge">I</code> and <code class="highlighter-rouge">K</code> by using the <code class="highlighter-rouge">#</code>-operator, to get the table size.</li>
  <li>Introduce the a function <code class="highlighter-rouge">is_prime</code> that calculates and returns the <code class="highlighter-rouge">PRIM</code> flag.</li>
</ul>

<p>While making these changes the logic of the calculation became more
apparent to me.  I hope that others might find this version also
easier to read.</p>

<h2 id="how-does-it-work">How does it work?</h2>

<p>So, what goes into the workings of this algorithm?</p>

<p>The table <code class="highlighter-rouge">P</code> contains the list of already computed prime numbers.</p>

<p>The nuber <code class="highlighter-rouge">x</code> is the current active prime candidate, which runs over
the odd numbers.  This is fair, since the case <code class="highlighter-rouge">P[1] = 2</code> has been
explicity taken care of. Within the iteration we can assume, that all
primes <code class="highlighter-rouge">p &lt; x</code> are listed in <code class="highlighter-rouge">P</code>.</p>

<p>To check, that <code class="highlighter-rouge">x</code> is prime, we have to check that no number <code class="highlighter-rouge">d</code> with
<script type="math/tex">% <![CDATA[
1 < d < x %]]></script> divides <code class="highlighter-rouge">x</code>.  The following reductions are well known:</p>

<ul>
  <li>It suffices to check the case <code class="highlighter-rouge">d</code> is a prime number.</li>
  <li>It suffices to check numbers <script type="math/tex">d \leq \sqrt{x}</script>.</li>
</ul>

<p>We call the smallest prime number, that we don’t have to check the
‘limit prime’ <code class="highlighter-rouge">q</code> and set <script type="math/tex">limit = q^2</script>.  Clearly <code class="highlighter-rouge">q</code> be the
smallest prime number such that <script type="math/tex">% <![CDATA[
\sqrt{x} < q %]]></script>.</p>

<p>It turns out, that the limit prime <code class="highlighter-rouge">q</code> is always smaller than <code class="highlighter-rouge">x</code>, and
hence we can find <code class="highlighter-rouge">q</code> in our table of already computed prime numbers:
<code class="highlighter-rouge">P[q_idx] = q</code>. (I was not able to find a simple proof of this
assertion, but it follows from
<a href="https://www.wikiwand.com/en/Bertrand's_postulate">Bertrand’s postulate</a>
quite easily.)</p>

<p>Now, the table <code class="highlighter-rouge">Q</code> maintains a list of multiples of the primes in <code class="highlighter-rouge">P</code>,
which are close to <code class="highlighter-rouge">x</code>:</p>

<ul>
  <li>
    <p>We want <code class="highlighter-rouge">Q[k]</code> to be the smallest multiple of <code class="highlighter-rouge">P[k]</code> so that <code class="highlighter-rouge">x &lt;=
Q[k]</code>.  If the condition is checked and maintained in the line:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if x &gt; Q[k] then Q[k] = Q[k] + P[k] end
</code></pre></div>    </div>

    <p><code class="highlighter-rouge">Q</code> is kept up to date with every candidate number <code class="highlighter-rouge">x</code> so we need to
add <code class="highlighter-rouge">P[k]</code> at most once in this step.</p>
  </li>
  <li>
    <p>The largest prime we need to check is the one before the limit prime
<code class="highlighter-rouge">q</code>, with index <code class="highlighter-rouge">P[q_idx-1]</code>. <code class="highlighter-rouge">Q</code> only stores values up to that
index.</p>
  </li>
</ul>

<p>Hence, by comparing <code class="highlighter-rouge">x</code> to <code class="highlighter-rouge">Q[k]</code> for equality we can can check if
<code class="highlighter-rouge">P[k]</code> divides <code class="highlighter-rouge">x</code>. Doing this for <code class="highlighter-rouge">k = 2..#Q</code>, gives a sufficient
condition for <code class="highlighter-rouge">x</code> being prime, according to the remarks above.</p>

<p>All in all, this algorithm is an interesting mix between the
Eratosthenes Sieve (that would maintain a list of all integers up to
x), and a naive test of divisibility by primes, up to
<script type="math/tex">\sqrt{x}</script>. Figure 2 contains my humble attempt to visualize (some
aspects of) the algorithm for the first few prime numbers.</p>

<figure id="figure-2"><a href="/assets/Dijkstra_files/visualization_2.png"><img src="/assets/Dijkstra_files/visualization_2.png" alt="A manual visualization of the algorithm" /></a><figcaption>Figure 2: A manual visualization of the algorithm [<a href="/assets/Dijkstra_files/visualization_2.png">PNG</a>]</figcaption></figure>

<p>The algorithm is also quite memory efficient. In addition to the list
of primes, we only store one integer for each prime up to
<script type="math/tex">\sqrt{x}</script>.  There are approximately <script type="math/tex">x/ln(x)</script> primes smaller than
<script type="math/tex">x</script> (cf. <a href="https://www.wikiwand.com/en/Prime_number_theorem">Prime-number-theorem</a>).
Hence the asymptotic memory requirements are:</p>

<script type="math/tex; mode=display">\frac{x}{ln(x)} + \frac{\sqrt{x}}{ln(\sqrt{x})} = \frac{x + 2 \sqrt{x}}{ln(x)} \sim \frac{x}{ln(x)}.</script>

<p>Which is the asymptotic size of the result set.</p>

<h2 id="open-ends">Open Ends</h2>

<p>At some point, I’d like to translate this algorithm to a pure
functional style, that avoids iteration and local variables and just
relies on function arguments and recursion. I hope that in this way
to correctness of the algorithm is easy to proof.</p>

<p>Also the visualization has clear room for improvement. Ideally, I’d
like to have a dynamic version of this, that updates itself as the
algorithm moves along. This will have to wait for another post.</p>

<h2 id="references">REFERENCES</h2>

<ol>
  <li>A.S. Tanenbaum - General-Purose Macro Processor as a Poor Man’s Compiler-Compiler, <a href="http://ieeexplore.ieee.org/xpl/login.jsp?tp=&amp;arnumber=1702350&amp;url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D1702350">IEEE TOSE, Sol.SE-2, No.2, JUNE 1976</a></li>
  <li>E.W. Dijkstra - Notes on Structured Programming (<a href="https://www.cs.utexas.edu/users/EWD/ewd02xx/EWD249.PDF">pdf</a>)</li>
</ol>

<h2 id="footnotes">Footnotes</h2>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>As pointed out by
<a href="https://news.ycombinator.com/item?id=11429163">amelius on HN</a> the
Eratosthenes sieve does not use divisions as well. I still find it
remarkable that you can avoid divisions, while not to computing
all multiples up-front and marking the results in a large table.&nbsp;<a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES * * */
  var disqus_shortname = 'heinrichhartmann';

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

<!--div id="related">
  <h2>Related Posts</h2>
  <ul class="posts">
    
      <li><span>29 Dec 2017</span> &raquo; <a href="/blog/2017/12/31/Quitting-Facebook.html">Quitting Facebook</a></li>
    
      <li><span>19 Nov 2016</span> &raquo; <a href="/blog/2016/11/19/The-Electoral-College.html">The Electoral College</a></li>
    
      <li><span>17 Nov 2016</span> &raquo; <a href="/opinion/2016/11/17/Bu-rgerversicherung-Bedroht-Arbeitspla-tze.html">Bürgerversicherung Bedroht Arbeitsplätze</a></li>
    
  </ul>
</div-->


  <div class="footer">
    <div class="contact">
      <p>
        Dr. Heinrich Hartmann<br />
        Math & IT Consulting<br />
        <a href="mailto:heinrich@heinrichhartmann.com">Heinrich@HeinrichHartmann.com</a>
      </p>
    </div>
    <div class="contact">
      <p>
        <a href="http://github.com/heinrichhartmann/">on GitHub</a><br />
        <a href="http://twitter.com/heinrichhartman/">on Twitter</a><br />
        <a href="http://www.slideshare.net/HeinrichHartmann">on SlideShare</a>
      </p>
    </div>
    <div class="rss">
      <p>Content under <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">CC-BY 4.0.</a>
        <span xmlns:dct="http://purl.org/dc/terms/" property="dct:title" style="display:none">This blog</span>
        <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName" style="display:none">Heinrich Hartmann</span>
        <br />
        icons by <a href="https://www.iconfinder.com/AlfredoCreates">Alfredo Creates</a></p>
        jekyll theme by <a href="https://github.com/mojombo/mojombo.github.io">Tom Preston-Werner</a><br/>
    </div>
  </div>
</div>

<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-53959000-1', 'auto');
  ga('send', 'pageview');
</script>

</body>
</html>
