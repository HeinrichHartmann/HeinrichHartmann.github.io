<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
   <title>Latency SLOs done right</title>
   <meta name="author" content="Heinrich Hartmann"/>

   <!-- syntax highlighting CSS -->
   <link rel="stylesheet" href="/css/syntax.css" type="text/css"/>

   <!-- Homepage CSS -->
   <link rel="stylesheet" href="/css/screen.css" type="text/css" media="screen, projection"/>

   <!-- RSS feed -->
   <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml">

   <!-- Favicon -->
   <link rel="icon" type="image/png" href="/images/favicon.png">

   
   <!-- Canonical source -->
   <link rel="canonical" href="https://www.circonus.com/2018/08/latency-slos-done-right/"/>
   
   </head>
<body>

<div class="site">
  <div class="title">
    <a href="/">Heinrich Hartmann</a>
    <a class="extra" href="/opinion.html">opinion</a>
    <a class="extra" href="/consulting.html">consulting</a>
    <a class="extra" href="/about.html">about</a>
    <div class="social" style='float:right'>
      <!-- <div style='float:right'> -->
      <!--   <a href="http://eepurl.com/ccmH-T"><img src="/images/mail_icon.svg" width="25px"/></a> -->
      <!-- </div> -->
      <div style='float:right'>
        <a href="/feed.xml"><img src="/images/rss_icon.svg" width="25px" style="margin: 0 10px 0 0;"/></a>
      </div>
      <div style='float:right'>
        <a href="http://twitter.com/intent/follow?screen_name=HeinrichHartman"><img src="/images/twitter_icon.svg" width="25px" style="margin: 0 10px 0 0;"></a>
      </div>
    </div>
  </div>
  

  <div id="post">

  <!-- Title -->
  <h1> Latency SLOs done right</h1>

  


  <!-- Meta -->
  <p class="meta">
    Written on 2018-09-02
     in Stemwede, Germany 
     for the <a href="https://www.circonus.com/2018/08/latency-slos-done-right/">Circonus blog</a>. 
  </p>

  <!-- Splash -->
  

  <!-- Post content -->
  <p>In their excellent SLO-workshop at SRECon2018 (<a href="https://www.usenix.org/conference/srecon18europe/presentation/fong-jones-0">program</a>) Liz Fong-Jones, Kristina Bennett and Stephen Thorne (Google) presented some best practice examples for Latency SLI/SLOs. At Circonus we care deeply about measuring latency and SRE techniques such as SLI/SLOs. As we will explain here, Latency SLOs are particularly delicate to implement and benefit from having Histogram-data available to  understand distributions and adjust SLO targets.</p>

<h2 id="latency-sli">Latency SLI</h2>

<p><img src="/images/2018-09-02-Latency-SLOs-done-right_5_0.png" alt="png" /></p>

<h2 id="latency-slo">Latency SLO</h2>

<p><img src="/images/2018-09-02-Latency-SLOs-done-right_7_0.png" alt="png" /></p>

<h2 id="latency-metrics">Latency Metrics</h2>

<p>These days latency is very typically measured with percentile metrics like these, which were presented for a similar use case:</p>

<p><img src="/images/2018-09-02-Latency-SLOs-done-right_9_0.png" alt="png" /></p>

<p>Given this data, what can we say about the SLO?</p>

<blockquote>
  <p>What is the p90 computed over the full 28days?</p>
</blockquote>

<p>It’s very tempting to take the average of the p90 metric which is displayed in the graph, which would be just below the 500ms mark.</p>

<p>It’s important to note, and it was correclty pointed out during the session, that this is not generally true.
You have no mathematical way determine the 28day-percentile from the series of 1h(?)-percentiles that are shown on the above graphs (<a href="https://www.reddit.com/r/devops/comments/941n2k/tsdbs_at_scale_part_one/e3po8d3/">reddit</a>, <a href="www.circonus.com/problem-math/">blog</a>, <a href="https://github.com/HeinrichHartmann/Statistics-for-Engineers/blob/master/2018-08-29-SRECon-Duesseldorf/3%20Data%20Aggregation%20Methods.ipynb">math</a>).
You need to look at different metrics if you want to implement a latency SLO. 
In this post we will discuss three different methods how to do this correctly.</p>

<h2 id="another-example">Another Example</h2>

<p>In the example above the error of averaging percentile might actually not be that dramatic.
The system seems to be very well-behaved with a very high constant load. 
In this situation like this the average p90/1h is typically close to the total p90/28days.</p>

<p>So let’s look at another API, which is less constantly loaded system.
This API does barely serve any load between 2:00am and 4:00am:</p>

<p><img src="/images/2018-09-02-Latency-SLOs-done-right_13_0.png" alt="png" /></p>

<p>What’s the true p90 over the 6h drawn on the graph? Is it above or below 30ms?</p>

<p>The average p90/1M (36.28ms) looks far less appealing then before.</p>

<h2 id="computing-latency-slos">Computing Latency SLOs</h2>

<p>So how to do better? There are three ways to go about this:</p>

<p>(1) compute the SLO from stored raw data (logs)</p>

<p>(2) count the number of bad requests in a separate metric</p>

<p>(3) use histograms to store latency distribution.</p>

<h3 id="method-1-using-rawlog-data">Method 1: Using Raw/Log data</h3>

<p>Storing access logs with latency data is clearly possible and gives you accurate results.
The drawback with this approach is that you must keep your logs over long time periods (28days) which can be very (very) expensive.</p>

<h3 id="method-2-counting-bad-requests">Method 2: Counting bad requests</h3>

<p>For the first case you will need to instrument you application to count the number of requests that violated your threshold.
The resulting metrics will look like this:</p>

<p><img src="/images/2018-09-02-Latency-SLOs-done-right_18_0.png" alt="png" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Percent good = 57862/60124 = 96.238%
</code></pre></div></div>

<p>Using this metrics we see that 96% of our requests over the past 6h were faster than 30ms. 
Our SLO stated, that 90% of the requests should be good.
So we met that objective.</p>

<p>The drawbacks of this appraoch is that you have to chosse the latency threshold upfront.
There is no way to calculate the percentage of requests that were faster than say 200ms form the recorded data.</p>

<p>If your SLO changes, you will need to change the executable or the service configuation to count requests above a different threshold.</p>

<h3 id="method-3-storing-histograms">Method 3: Storing Histograms</h3>

<p>The third practical option you have for computing accurate SLOs is storing your request latency data as histograms.
The advantage of storing latency data as histograms are that:</p>

<p>(1) Histograms can be freely aggregated across time.</p>

<p>(2) Histograms can be used to derive approximations of arbitrary percentiles.</p>

<p>For (1) to be true, it’s critical, that your histograms have common bin choices.
It’s usually a good idea to mandate the bin boundaries for your whole organization.
Otherwise you will not be able to aggregate histograms from different services.</p>

<p>For (2) it’s critical that you have enough bins in the latency range that is relevant for your percentile.
Sparsely encoded log linear histograms allow you to cover a large floating point range (E.g. <code class="highlighter-rouge">10^-127..10^128</code>) with a fixed relative precision (E.g. 5%).
In this way you can guarantee 5% accuracy on all percentiles, no matter how the data is distributed.</p>

<p>Two popular implementations of log linear histograms are:</p>

<ul>
  <li>HDR-Histogram - https://HDrhistogram.org</li>
  <li>Circllhist - https://github.com/circonus-labs/libcircllhist/</li>
</ul>

<p><a href="https://circonus.com">Circonus</a> (where I work) comes with native support for Circllhist and will be used for this example.</p>

<p>Histogram metrics store latency information per minute, and are commonly visualized as heatmap:</p>

<p><img src="/images/2018-09-02-Latency-SLOs-done-right_25_0.png" alt="png" /></p>

<p>Merging those 360x1M-histograms shown above into a single 6h-Histogram, we arrive at the following graph:</p>

<p><img src="/images/2018-09-02-Latency-SLOs-done-right_27_0.png" alt="png" /></p>

<p>This is the true latency distribution over the full SLO reporting period of 6h (in this case).</p>

<p>At the time of this writing, there is no nice UI option to overlay percentiles in the above histogram graph.
As we will see, you can perform the SLO calculation with CAQL or Python.</p>

<h3 id="slo-reporting-via-caql">SLO Reporting via CAQL</h3>

<p>We can use the CAQL functions <code class="highlighter-rouge">histogram:rolling(6h)</code> and <code class="highlighter-rouge">histogram:percentile()</code> to aggregate histograms over the last 6h and compute precentiles over the aggregated histograms. 
The SLO value we are looking for will be the very last value displayed on the graph.</p>

<p><img src="/images/2018-09-02-Latency-SLOs-done-right_31_0.png" alt="png" /></p>

<h3 id="slo-reporting-using-python">SLO Reporting using Python</h3>

<p>Using the Python API the calculation could look as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 0. Setup Python</span>
<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
<span class="kn">from</span> <span class="nn">circonusapi</span> <span class="kn">import</span> <span class="n">circonusdata</span>
<span class="kn">from</span> <span class="nn">circllhist</span> <span class="kn">import</span> <span class="n">Circllhist</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s">"~/host/home/.circonusrc.json"</span><span class="p">),</span><span class="s">"r"</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fh</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 1. Fetch Histogram Data</span>
<span class="n">t</span> <span class="o">=</span> <span class="mi">1528171020</span> <span class="c"># exact start time of the graph </span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">364</span>        <span class="c"># exact number of minutes on the above graph</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">circonusdata</span><span class="o">.</span><span class="n">CirconusData</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s">"demo"</span><span class="p">])</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">circ</span><span class="o">.</span><span class="n">caql</span><span class="p">(</span><span class="s">'search:metric:histogram("api`GET`/getState")'</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 2. Merge Histograms</span>
<span class="n">H</span><span class="o">=</span><span class="n">Circllhist</span><span class="p">()</span>
<span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s">'output[0]'</span><span class="p">]:</span> <span class="n">H</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Let's check the fetched data is consistent with Histogram in the UI</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">circllhist_plot</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(0, 100)
</code></pre></div></div>

<p><img src="/images/2018-09-02-Latency-SLOs-done-right_37_1.png" alt="png" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 3. Calculate Aggregated Precentiles:</span>
<span class="n">P</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">95</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mf">99.9</span><span class="p">]</span> <span class="c"># arbitrary percentiles</span>
<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">P</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="s">"{:&gt;8}-latency percentile over 6h: {:&gt;8.3f}ms"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">p</span><span class="o">/</span><span class="mi">100</span><span class="p">)))</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      50-latency percentile over 6h:   13.507ms
      90-latency percentile over 6h:   21.065ms
      95-latency percentile over 6h:   27.796ms
      99-latency percentile over 6h:   56.058ms
    99.9-latency percentile over 6h:  918.760ms
</code></pre></div></div>

<p>In particular we see that the true p90 is around 21ms, which is far away from the average p90 of 36.28 we computed earlier.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 4. Calculate Aggregated Counts:</span>
<span class="n">Y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">]</span> <span class="c"># Arbitrary thresholds</span>
<span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="s">"{:&gt;10.3f} percent faster than {}ms"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">count_below</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">H</span><span class="o">.</span><span class="n">count</span><span class="p">()</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span><span class="n">y</span><span class="p">))</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    18.465 percent faster than 10ms
    96.238 percent faster than 30ms
    98.859 percent faster than 50ms
    99.484 percent faster than 100ms
    99.649 percent faster than 200ms
</code></pre></div></div>

<p>In particular we replicate the “96.238% below 30ms” result, that we calculated using the counter metrics before.</p>

<h2 id="conclusion">Conclusion</h2>

<p>It’s imporant to understand that percentile metrics do not allow you to implement accurate Service Level Objectives that are forumlated against hours or weeks.
Aggregating 1M-percentiles seems tempting but can produce materially wrong results, in particular if your load is highly volatile.</p>

<p>Practical ways to calculate correct SLO percentiles are counters and histograms.
Histograms give you additional flexibility to choose the latency threshold after the fact.
This comes in particularly handy when you are still evaluating your service and are not ready to commit yourself to a latency threshold just yet.</p>


  <!-- Comments -->
  
    <em>Comments have been disabled until the dust around the GDPR settled.</em>
    <!-- <div id="disqus_thread"></div> -->
    <!-- <script type="text/javascript"> -->
    <!--   /* * * CONFIGURATION VARIABLES * * */ -->
    <!--   var disqus_shortname = 'heinrichhartmann'; -->
    <!--   /* * * DON'T EDIT BELOW THIS LINE * * */ -->
    <!--   (function() { -->
    <!--   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; -->
    <!--   dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; -->
    <!--   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); -->
    <!--   })(); -->
    <!-- </script> -->
    <!-- <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments</a></noscript> -->
  

</div>


  <div class="footer">
    <div class="contact">
      <p>
        Licensed under <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">CC-BY 4.0.</a>
        <span xmlns:dct="http://purl.org/dc/terms/" property="dct:title" style="display:none">This blog</span>
        <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName" style="display:none">Heinrich Hartmann</span>
      </p>
    </div>
  </div>
</div>



<!-- Google Analytics -->

<!-- <script> -->
<!--   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ -->
<!--   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), -->
<!--   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) -->
<!--   })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); -->

<!--   ga('create', 'UA-53959000-1', 'auto'); -->
<!--   ga('send', 'pageview'); -->
<!-- </script> -->

</body>
</html>
