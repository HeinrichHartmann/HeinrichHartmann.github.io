<!doctype html><html lang=""><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="favicon.ico"><title>sampling</title><script defer="defer" src="js/chunk-vendors.05daf7b7.js"></script><script defer="defer" src="js/app.b57916f1.js"></script></head><body><header><a href="/">HeinrichHartmann.com</a></header><main class="markdown-container"><article class="markdown-body"><noscript><strong>We're sorry but sampling doesn't work properly without JavaScript enabled. Please enable it to continue.</strong></noscript><div id="app"></div><h2 id="explanation">Explanation</h2><h3 id="sampling-method">Sampling Method</h3><p>We model the error introduce by <a href="https://en.wikipedia.org/wiki/Bernoulli_sampling">Bernuoulli sampling</a> to a number of statistics that are relevant for IT operations. This sampling model used by OpenTelemetry to sample on trace-level (although the <a href="https://github.com/open-telemetry/oteps/blob/main/text/trace/0170-sampling-probability.md#traceidratio-sampler">spec</a> is not clear on this.)</p><p>In the model, we start with the full dataset $X$ (the &quot;population&quot;) that we assume to be available to us. We produce a sampled dataset $S$ (the &quot;sample&quot;).</p><p>For each point in the population we make independent sampling decisions with probability given by the sampling rate.</p><ul><li>With sampling rate 100% all the elements in the population are retained.</li><li>With sampling rate 50%, there is a 50% chance that any given point will be retained.</li><li>With sampling rate 0% the sample is empty.</li></ul><h3 id="estimation">Estimation</h3><p>For some statistics, we have theoretical models that allow us to estimate the expected values and variances.</p><h4 id="count-estimation">Count Estimation</h4><p>In the Bernoulli model, the sample size $n=\# S$ follows a <a href="https://en.wikipedia.org/wiki/Binomial_distribution#Statistical_inference">Binomial distribution</a> $$n \sim B(N,p)$$ where with $p$ is the sampling rate $p$, and $N = \#X$ is population size. Hence the expected sample size is $E[n] = N \cdot p$, and $Var[n] = N \cdot p \cdot (1-p)$. These formulas are used to calculate the <em>Request Count</em> and <em>Request Rate</em> statistics.</p><p>For the error rate calculation, we assume that $X_e \subset X$ is a subset of &quot;error&quot; requests. Applying Bernoulli sampling, we get $S_e = X_s \cap S \subset S$, the set of errors in the sample.</p><p>The error count $n_e = \# S_e$ follows a binomial distribution $n_e \sim B(N_e,p)$, where $N_e = \# X_e$.</p><p>Unfortunately, the distribution of the error rate $r_e = \# S_e / \# S$ is not easily derived. It can be roughly approximated by $\# S_e / (N_e \cdot p)$, which is what we use in the table above. Simulation shows, that this estimate breaks down for larger error rates e.g. $X_e = X$.</p><h3 id="simulation">Simulation</h3><p>We simulate multiple iterations of sampling decisions is straight forward.</p><ul><li>We repeatedly select a subset $S \subset X$ by running bernoulli experiments for each sample $x \in X$.</li><li>We compute the estimator on the sample $S$, and record the results.</li><li>In the above tables we report mean, and standard-deviation of the computed estimations.</li><li>Note that mean and standard-deviation are sensible measure here, since the distribution of the estimators across different samples is well behaved (very close to normal), in all cases.</li></ul></article></main><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({
      tex2jax: {
        displayMath: [['$$','$$']],
        inlineMath: [['$','$']],
        processEscapes: false
      }
    });</script></body></html>